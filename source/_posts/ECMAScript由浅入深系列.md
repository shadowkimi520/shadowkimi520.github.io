---
title: ECMAScript由浅入深系列(规范深入系列)
date: 2017-09-11 20:48:18
tags:
---

## 写在前面
ECMAScript由浅入深系列共计15篇已经正式完结，这是一个旨在帮助大家，其实也是在帮助自己全面把握ECMAScript语言核心知识的系列。本系列由浅入深的讲解了JS语言核心的方方面面，从语言层面的基本概念入手，逐步深入，规范总结JS引擎在底层是如何实现这些问题的。知其然，而又知其所以然是这个系列的宗旨！

front-end JS = ECMAScript + DOM + BOM
server-end JS = ECMAScript + ServerAPI

本系列自2017/9/11开始编写，感谢各位朋友的收藏、点赞，鼓励、指正。

参照 [ES2018(Draft)标准](https://tc39.github.io/ecma262/ "ES2018-SPEC")

而此篇，作为ECMAScript由浅入深系列的总结篇，除了汇总各篇文章，作为目录篇之外，还希望跟大家聊聊自己写这个系列的动机，希望就“技术不安感”找到有相同困惑并愿意深入理解的你！

## 我为什么要写ECMAScript由浅入深系列？
做为一个初入前端的小菜鸟，这个系列也概括了我自学ECMAScript的心路历程；前端的技术更新如此之快，技术栈如此之深，多种框架类库各领风骚，常常发生离开了框架就不会写代码的情况；发现大家都依赖于框架，框架配置、文件组织、框架API能够熟练掌握，如果仅仅是为了解决工作上的问题，或许已经足够；但仅仅会用，或者只是记住怎么样，内心经常还会冒出一种不安定感，这种不安定感来自于对自己的代码如何被执行的未知部分的恐惧；或许来自于解决问题却不明所以的尴尬，或许来自于屡次想深入理解却不得门道的失败。。。代码写的越久，这种感觉就越是明显。说实话，这些不看不影响一般写代码，而且是功能很复杂的代码。

深入能够帮助理解为何会这样，但硬币的另一面是：深入到何处为止？过分想了解底层，往往会分散对于当前问题的注意力，从而导致思维混乱；深入的宗旨是解决上层问题，也就是回答我们心中的关于JS执行过程的疑惑，因此采用分层的思维来处理这个问题就再适合不过了。所有的JS代码都要通过引擎来执行，而JS解析引擎要遵循ECMAScript规范来实现，因此我们可以通过ECMAScript规范来描述代码执行过程中发生的事情，这样就能理解为什么是这样而不是那样。至于引擎是用C++还是用JAVA实现的，内部变量如何存储的对于我们理解上层的问题没有多大影响，只要它是按标准实现的就行。

有一段时间一直困惑我的一个问题是：为什么ES6能新增一种Symbol原始类型，怎么能说增加就增加？拥有[[description]]属性的原始类型。JS为什么会区分原始值类型和引用类型？因为它们在判断相等和类型转换方面存在差异，规范里在原始值类型的转型处理方面就与引用类型独立开来处理。其实底层通过一种C++的对象类型来表示Symbol类型，在JS层面它是原始类型，因为规范给予了它区别于对象类型的处理方式；而在实现层面它是一种对象类型，是对一块实际内存的不同解释方式而已；之所以说在JS层面它是一种原始类型，是因为它不包含任何属性，而JS的对象类型是一系列属性的集合，而且规范对它的处理方式也不同。

*I know i was late to the party， 我只能死磕自己！*
*以大多数人的努力程度之低，根本轮不到拼天赋。。。*

声明：这个系列受**[冴羽](https://segmentfault.com/a/1190000009562674)** JavaScript深入系列启发，有以下几点思考：
1. 只有做点什么，才知道自己的潜力有多大！