---
title: 值&&类型&&变量
date: 2017-05-15 10:38:02
tags: JS primitive
---

大多数人认为，JS作为动态语言是没有类型的；ES5.1规范明确说明：规范中的所有运算符所操纵的值都有相应的类型。ECMAScript语言中所有的值都有一个对应的语言类型：

### 语言类型
JS有七种***内置类型***：Undefined、Null、Boolean、String、Number、Object、 Symbol (ES6), 除对象外其他统称为“*基本类型(原始类型 primitive type)* ”
__typeof__ 操作符返回字符串为"undefined", "function", "boolean", "number", "string", "object"
```js
typeof null ==> 'object'
(!a && typeof a === 'object')  // 检测 null 值

1e+10.toString();
1e+21.toString();
10..toString();
```
* 内置对象 与 原生对象的区别；以及宿主对象
* 类型是值的内部特征，它定义了值的行为特征，以使其区别于其他值;
* JS中原始类型之间的强制转换及隐式转换<br/>&nbsp;&nbsp;&nbsp;&nbsp;不会调用原始类型对应包装对象的任何方法，比如Number -> String的转换，不会调用(5).toString()来完成，String(5)内部会自动执行相应的转换操作(比如确定最后的结果是否以指数形式显示等等)；相反(5).toString方法可能会在内部调用String(5)来完成字符串格式的输出;
* 对象到Boolean/String/Number的转换适用特定的规则，比如到String的转型优先调用toString()方法，如果该方法返回一个原始值，则再对该原始值执行到String的转换；否则调用valueOf()方法，再对得到的原始值执行到String的转换；否则TypeError: Cannot convert object to primitive value;
* 一些运算符会对操作数执行到原始值的特殊转换, 比如+，<, <=等; 此时不同运算符针对不同类型的对象会适用不同的到原始值的类型转换规则;
* 对变量执行typeof操作时，返回变量持有的值的类型，而不是变量的类型，因为JS中的变量是没有类型的，只有值才有，变量可以随时持有任何类型的值;
```js
typeof something !== 'undefined' && something // 用于获取something, 避免ReferenceError
```

### undefined 与 null
* undefined和null都是对应类型的唯一值，分别对应于Undefined类型和Null类型

### Array对象的toString()方法
* 一般来说，String(argu)与ToString(argu)抽象操作的结果是一样的，因为String内部会调用ToString抽象操作；
* 但是作用于Symbol原始值结果却不同：
```js
var s = Symbol('abc');
String(s) // 'Symbol(abc)'
s + '';  // TypeError: Cannot convert a Symbol value to a string
var arr = [s, s, s];
String(arr) // TypeError: Cannot convert a Symbol value to a string
arr.toString(); // // TypeError: Cannot convert a Symbol value to a string
// 由此可见，数组在串接成字符串时，对每个数组成员直接调用ToString抽象操作，而不是通过String()函数，因为String(symbol原始值)能得到正确的字符串值
var s_obj = Object(s);
String(s_obj); // TypeError: Cannot convert a Symbol value to a string
// 因为String函数对Symbol对象类型会通过ToString抽象操作调用ToPrimitive抽象操作，而ToPrimitive(hint=String)抽象操作作用于Symbol对象时调用其自身的@@primitive返回Symbol原始值，ToString(Symbol原始值)会抛出TypeError
```

### String构造函数
* String(undefined) // 'undefined'
* String() // ''

### Number构造函数
* Number(undefined) // NaN
* Number() // 0
* undefined + 0 // NaN
* Number(undefined) // NaN
```js
var s = Symbol('abc');
s + 0; // TypeError: Cannot convert a Symbol value to a number
Number(s); // TypeError: Cannot convert a Symbol value to a number
// ToNumber抽象操作与Number()函数是一致的
```

### RegExp构造函数
* RegExp以函数方式调用，返回空的正则表达式
```js
var r = RegExp();
r; // /(?:)/
Object.prototype.toSting.call(r); // '[object RegExp]'
Object.prototype.toString.call(RegExp.prototype) // '[object Object]'
// RegExp是以一个普通对象存在的吗？难道不是作为一个正则表达式对象？
// 参见ECMAScript2015-Page274 是一个普通对象
```



### Closures
Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions 'remember' the environment in which they were created.


### 运算符

运算符的优先级：优先级高指的是优先与操作数结合进行运算，其计算结果作为低优先级操作符的一个操作数；但短路特性的运算符可能提前返回结果，无需分别计算多个操作数。

运算符的优先级是语法分析阶段的概念；而短路特性是语义分析及代码生成阶段的概念，这两个不是对立的！

+ 和 += 这两个操作符都会优先进行字符串的串接操作；复合赋值操作符的特点是左侧操作数只会计算一次，参考12.15.4 RS：Evaluation


### DOM Object

HTMLCollection 和 NodeList对象的length属性是一个代理到原型的存取器属性；而且拥有虚拟的整数索引属性。

